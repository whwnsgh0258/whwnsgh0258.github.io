---
title: Sync vs Async
description: 동기 vs 비동기
date: 2025-03-12 11:33:00 +0800
published: true
author: 조준호
categories: [ java, cs ]
tags: [ java, cs ]
sitemap:
  changefreq: daily
  priority: 1.0
---

# 동기 vs 비동기

## 1. 동기와 비동기의 개념

**동기(Synchronous)** 와 **비동기(Asynchronous)** 는 프로그램이 작업을 처리하는 방식입니다.  
두 개념은 작업을 요청 한 후 결과를 기다리는 방식의 차이에 따라 구분되며, 성능과 응답 속도에 영향을 미칩니다.

### 1.1 동기(Synchronous)

동기 방식에서는 **작업이 순차적으로 실행**되며, 이전 작업이 완료된 이후에 다음 작업이 실행됩니다.
section 비동기 처리
![동기_처리_방식](/assets/img/postImg/03:12/동기_처리_방식.png)

### 1.2 비동기(Asynchronous)

비동기 방식에서는 **작업이 완료될 때까지 기다리지 않고**, 다른 작업을 **병렬로 처리**할 수 있습니다.
![비동기_처리_방식](/assets/img/postImg/03:12/비동기_처리_방식.png)

## 2. 동기와 비동기 처리의 선택 기준

서버 개발을 할때는 작업의 특성과 성능을 고려하여 동기와 비동기 방식을 선택해야 합니다.

### 2.1 동기 처리

동기 처리 방식은 **작업 순서를 보장해야 하거나, 데이터의 일관성이 중요한 경우에 적합 합니다.**

- **예시**
  - **트렌잭션이 필요한 작업(DB 연산)**
    - 예: 계좌 이체
  - **순차적인 비즈니스 로직을 처리해야 하는 경우**
    - 예: 은행 서비스 및 주문 시스템에서 결제 완료 후 주문 생성 등
  - **외부 API 호출 후 결과를 받아서 처리해야 하는 경우**
    - 예: 서버가 다른 서버의 API를 호출하고, 그 결과를 받아서 다음 작업을 수행해야 하는 경우.
  - **동기적인 I/O 작업**
    - 예: 파일을 읽고 그 결과를 가공한 후, 가공된 데이터를 즉시 클라이언트에게 반환하는 경우.

- **장점**
  - **코드가 간단하고 직관적** - 순차적으로 실행되기 때문에 코드의 흐름을 파악하기 쉽습니다.
  - **데이터의 일관성 보장** - 작업이 끝날 때 까지 다음작업이 실행되지 않기 때문에, 데이터의 무결성을 보장할 수 있습니다.
  - **예측 가능한 동작** - 작업이 순차적으로 실행되기 때문에, 작업의 순서를 예측할 수 있습니다.
- **단점**
  - **성능 저하** - 하나의 작업이 처리되는 동안 다른 작업은 블로킹 됩니다.
  - **응답 시간이 길어질 수 있음** - 작업이 순차적으로 실행되기 때문에, I/O 작업이 많은 경우 응답 시간이 길어질 수 있습니다.
  - **멀티스레드 환경에서 확장성이 낮음** - 많은 요청을 한번에 수행해야 하는 경우 비효율적입니다.

### 2.2 비동기 처리

비동기 처리 방식은 **병렬적인 처리와 높은 성능을 요구하는 경우**에 적합합니다.

- **예시**
  - **대량의 요청을 처리해야 하는 경우 (웹 서버, API 서버)** 
    - 예: 서버가 많은 요청을 한번에 처리해야 하는 경우
  - **멀티스레딩을 활용한 백그라운드 작업** 
    - 예: 이메일 전송, 푸시 알림, 배치 작업 등 사용자가 응답을 기다리지 않아도 되는 작업
  - **파일 업로드 및 다운로드**
    - 예: 파일 업로드, 다운로드, 이미지 처리 등의 작업을 하는동안 다른 작업 수행 가능
  - **비동기 이벤트 기반 시스템 (Kafka, RabbitMQ 등)**
    - 예: **메시지 큐 기반 시스템**에서 이벤트가 발생하면 처리하는 방식

- **장점**
  - **성능 및 확장성이 뛰어남** -> 요청을 병렬로 처리할 수 있어 고성능 서버 구축 가능.
  - **빠른 응답 속도** -> 블로킹을 방지하여 사용자 경험(UX) 향상.
  - **리소스 효율적 사용** -> 네트워크 대기 시간을 줄이고, CPU를 효율적으로 활용할 수 있음.

- **단점**
  - **코드가 복잡해짐** -> 콜백, Future, Reactive API 사용으로 코드가 복잡해질 수 있음.
  - **예외 처리 및 디버깅이 어려움** -> 동기 방식보다 버그 추적이 어려움.
  - **데이터 일관성 문제** -> 여러 작업이 동시에 실행되면서 데이터 동기화 이슈가 발생할 수 있음.
